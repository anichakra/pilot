package me.anichakra.poc.pilot.framework.io.pdf;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.util.Collection;
import java.util.Locale;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;

import me.anichakra.poc.pilot.framework.annotation.Export;
import me.anichakra.poc.pilot.framework.batch.DataProcessor;
import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.Font;
import com.lowagie.text.Phrase;
import com.lowagie.text.pdf.CMYKColor;
import com.lowagie.text.pdf.PdfPCell;
import com.lowagie.text.pdf.PdfPTable;
import com.lowagie.text.pdf.PdfWriter;

/**
 * This data processor processes the data and create pdf file using apache
 * POI. This class is not thread-safe, so cannot be used as a singleton class. Might face Race-condition if used.
 * 
 * @author Anirban C1
 *
 * @param <K>
 * @param <K>
 */
public class PDFDataProcessor<K> implements DataProcessor<K, Void> {

	public static final String FILE_EXTENSION = "pdf";

	private static final Logger LOGGER = LogManager.getLogger();
	private Document document = null;

	private String workSheetName;

	private File filePath;

	private String filePattern;

	private String jobId;
	
	private MessageSource messageSource;

	private int totalNoOfColumns;
	private PdfPTable pdfTable = null;
	private OutputStream outputStream = null;
	
	 

	/**
	 * Creates an pdfDataProcessor using the file path and file pattern of the
	 * pdf file to be generated. The file name of the created file for a batch
	 * process will be <code>jobId+"_"+filePattern+".pdf"</code>. Hence the
	 * filePattern should not contain the extension of the file. The generated
	 * file will have extension will be <code>pdf</code>.
	 * 
	 * @param filePath
	 *            The path where the pdf file will be generated by the batch
	 *            process
	 * @param filePattern
	 *            The pattern of the file, e.g vehicle_list, driver_list
	 * @param workSheetName
	 */
	public PDFDataProcessor(File filePath, String filePattern, String workSheetName,MessageSource messageSource) {
		this.workSheetName = workSheetName;
		this.filePath = filePath;
		this.filePattern = filePattern;
		this.messageSource = messageSource;
	}

	/**
	 * The header is created from a sample record. It uses {@link Export}
	 * annotation marked on the fields in the class of the input object to
	 * create the header.
	 * 
	 * @param obj A sample object whose attributes marked as {@link Export} will be used to create the header
	 * @param workbook The pdf workbook where the header is created
	 * @param sampleDataSheet A sample data sheet
	 * @param rowCount The number of rows for header
	 * @param colCount The number of colums for header
	 */
	protected void createHeader(Object obj) {
		
	
		this.pdfTable.setWidthPercentage(100);
		this.pdfTable.getDefaultCell().setBackgroundColor(CMYKColor.BLACK);
        Font font = new Font(Font.HELVETICA, 12, Font.BOLD, CMYKColor.WHITE);
        for(int i=0;i<this.totalNoOfColumns;i++){
		for (Field field : obj.getClass().getDeclaredFields()) {
			if (field.isAnnotationPresent(Export.class)) {
				field.setAccessible(Boolean.TRUE);
				try {
					Export pdfAttribute = field.getAnnotation(Export.class);
					if(pdfAttribute.columnSeq()==i){
					//if (field.get(obj) != null && !field.get(obj).toString().isEmpty()) {
						//LOGGER.debug(pdfAttribute.columnName()+"::"+localizeColumnName(pdfAttribute.columnName()));	
						Phrase p = new Phrase(localizeColumnName(pdfAttribute.columnName()));
						//Phrase p = new Phrase(pdfAttribute.columnName());
						PdfPCell cell = new PdfPCell(p);
						this.pdfTable.addCell(cell);
					//}
					break;
					}
				} catch (IllegalArgumentException e) {
					throw new PDFCreationException("ERROR_JOB_PDFHEADER", e);
				} 
			}
		}
	}

	}

	/**
	 * 
	 * @param data
	 * @param sampleDataSheet
	 * @param rowCount
	 * @param colCount
	 */
	protected void createDataRows(Collection<K> data) {
		for (Object domain : data) {			
			createColumnData(domain);
			
		}
	}

	/** Compute table cell value from given data */
	protected void createColumnData(Object object) {
		for(int i=0;i<this.totalNoOfColumns;i++){
			
			for (Field field : object.getClass().getDeclaredFields()) {
				if (field.isAnnotationPresent(Export.class)) {
					field.setAccessible(Boolean.TRUE);
					try {
						Export pdfAttribute = field.getAnnotation(Export.class);
						if(pdfAttribute.columnSeq()==i){
						if (field.get(object) != null && !field.get(object).toString().isEmpty()) {

							if (field.get(object) != null){
								Phrase p = new Phrase(field.get(object).toString());
								PdfPCell cell = new PdfPCell(p);
								this.pdfTable.addCell(cell);
							
							}
						}
						break;
						}
					} catch (IllegalArgumentException e) {
						throw new PDFCreationException("ERROR_JOB_PDFCOLUMN", e);
					} catch (IllegalAccessException e) {
						throw new PDFCreationException("ERROR_JOB_PDFCOLUMN", e);
					}
				}
			}
		}
		
		
		

	}

	

	public void preProcess(String jobId, Object obj) {
		this.jobId = jobId;
		this.document = new Document();
		 try {
			 this.outputStream=createOutputStream();
			PdfWriter.getInstance(this.document,outputStream);
		} catch (DocumentException e1) {
			throw new PDFCreationException("ERROR_JOB_pdfCOLUMN", e1);
		}
		 this.document.open();
		
		// sampleDataSheet.setRandomAccessWindowSize(10);
		this.pdfTable = new PdfPTable(getNoOfColumns(obj));
		this.pdfTable.setWidthPercentage(100);
		createHeader(obj);
		
	}

	private int getNoOfColumns(Object object) {
			int i =0;
		for (Field field : object.getClass().getDeclaredFields()) {
			if (field.isAnnotationPresent(Export.class)) {
				i++;
			}
		}
		this.totalNoOfColumns=i;
	return i;
	}

	public Collection<Void> process(Collection<K> data) {
		LOGGER.debug("preparepdf>>");	

		createDataRows(data);
		
		return null;
	}

	public void postProcess(Object obj) {
		//OutputStream outputStream =PdfWriter.get
		LOGGER.debug("writepdfTo>>" + outputStream);
		try {
			try {
				document.add(this.pdfTable);
			} catch (DocumentException e) {
				// TODO Auto-generated catch block
				throw new PDFCreationException("ERROR_JOB_pdfCLOSE", e);
			}
			document.close();
			
			

		}  finally {
			try {
				if (this.outputStream != null) {
					this.outputStream.close();
				}
			} catch (IOException e) {
				throw new PDFCreationException("ERROR_JOB_pdfCLOSE", e);
			}
		}

		
	}

	

	/** To create the OutputStream for writing pdf */
	public OutputStream createOutputStream() {
		FileOutputStream fileOutputStream = null;
		LOGGER.debug(filePath.getAbsolutePath(), jobId + "_" + filePattern + "." + FILE_EXTENSION);
		File file = new File(filePath, jobId + "_" + filePattern + "." + FILE_EXTENSION);
		
		

		try {
		    createFile(file);
		    fileOutputStream = new FileOutputStream(file);
        
		} catch (Exception e) {
			throw new PDFCreationException("ERROR_JOB_pdfWRITE", e);
		}

		return fileOutputStream;
	}
	public boolean createFile(File file) {
	    
	    boolean flag;
        if (file.getParentFile().exists() == false) {
            flag = file.getParentFile().mkdir();
        }
        try {
            return flag = file.createNewFile();
        } catch (IOException e) {
            throw new PDFCreationException("ERROR_JOB_pdfWRITE", e);
        }
         
        
	    
	}
	
	public String localizeColumnName(String name) {
		if (name.equals("")){
			return "";
		}
		Locale locale = LocaleContextHolder.getLocale();
		String errorMessage = messageSource.getMessage(name, null, locale);
		return errorMessage;
	}

}
