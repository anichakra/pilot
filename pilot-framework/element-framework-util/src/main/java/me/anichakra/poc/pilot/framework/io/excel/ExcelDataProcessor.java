package me.anichakra.poc.pilot.framework.io.excel;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.Collection;
import java.util.Locale;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.Font;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.xssf.streaming.SheetDataWriter;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;

import me.anichakra.poc.pilot.framework.annotation.Export;
import me.anichakra.poc.pilot.framework.batch.DataProcessor;

/**
 * This data processor processes the data and create excel file using apache
 * POI. This class is not thread-safe, so cannot be used as a singleton class. Might face Race-condition if used.
 * 
 * @author Anirban C1
 *
 * @param <K>
 * @param <K>
 */
public class ExcelDataProcessor<K> extends DataProcessorTemplate<K> implements DataProcessor<K, Void> {

	public static final String FILE_EXTENSION = "xls";

	private static final Logger LOGGER = LogManager.getLogger();

	private HSSFWorkbook workbook = null;

	private String workSheetName;

	private File filePath;

	private String filePattern;

	private String jobId;
	
	private MessageSource messageSource;

	/**
	 * Creates an ExcelDataProcessor using the file path and file pattern of the
	 * excel file to be generated. The file name of the created file for a batch
	 * process will be <code>jobId+"_"+filePattern+".xls"</code>. Hence the
	 * filePattern should not contain the extension of the file. The generated
	 * file will have extension will be <code>xls</code>.
	 * 
	 * @param filePath
	 *            The path where the excel file will be generated by the batch
	 *            process
	 * @param filePattern
	 *            The pattern of the file, e.g vehicle_list, driver_list
	 * @param workSheetName
	 */
	public ExcelDataProcessor(File filePath, String filePattern, String workSheetName,MessageSource messageSource) {
		this.workSheetName = workSheetName;
		this.filePath = filePath;
		this.filePattern = filePattern;
		this.messageSource = messageSource;
	}

	/**
	 * The header is created from a sample record. It uses {@link Export}
	 * annotation marked on the fields in the class of the input object to
	 * create the header.
	 * 
	 * @param obj A sample object whose attributes marked as {@link Export} will be used to create the header
	 * @param workbook The excel workbook where the header is created
	 * @param sampleDataSheet A sample data sheet
	 * @param rowCount The number of rows for header
	 * @param colCount The number of colums for header
	 */
	@Override
	protected void createHeader(Object obj, HSSFWorkbook workbook, HSSFSheet sampleDataSheet, int rowCount,
			int colCount) {
		Row header = sampleDataSheet.createRow(rowCount);
		CellStyle headerCellStyle = setHeaderStyle(workbook);
		for (Field field : obj.getClass().getDeclaredFields()) {
			if (field.isAnnotationPresent(Export.class)) {
				field.setAccessible(Boolean.TRUE);
				try {
					    Export excelAttribute = field.getAnnotation(Export.class);
						header.createCell(excelAttribute.columnSeq()).setCellValue(localizeColumnName(excelAttribute.columnName()));
						header.getCell(excelAttribute.columnSeq()).setCellStyle(headerCellStyle);
				
				} catch (IllegalArgumentException e) {
					throw new ExcelCreationException("ERROR_JOB_EXCELHEADER", e);
				} 
			}
		}

	}

	/**
	 * 
	 * @param data
	 * @param sampleDataSheet
	 * @param rowCount
	 * @param colCount
	 */

	@Override
	protected void createDataRows(Collection<K> data, HSSFSheet sampleDataSheet, int rowCount, int colCount) {
		int rowcCounter=0;
		for (Object domain : data) {
			rowcCounter++;
			if(rowcCounter<1000){
				Row dataRow = sampleDataSheet.createRow(rowCount);
				colCount = 0;
				createColumnData(domain, dataRow, colCount);
				rowCount++;
			}
		}
	} 

	ConcurrentHashMap<Integer, Field> concurrentHashMap = new ConcurrentHashMap<Integer, Field>();
	 

	/** Compute table cell value from given data */
	@Override
	protected void createColumnData(Object object, Row dataRow, int colCount) {
		try {			
		if(concurrentHashMap!=null && concurrentHashMap.size()>0){
			for (Entry<Integer, Field> entry : concurrentHashMap.entrySet()) {
			    Integer seq = entry.getKey();
			    Field field = entry.getValue();
			    if (field.get(object) != null && !field.get(object).toString().isEmpty()) {

					if (field.get(object) != null)
						dataRow.createCell(seq.intValue()).setCellValue(field.get(object).toString());
				}
			}
		}else{
		for (Field field : object.getClass().getDeclaredFields()) {
			if (field.isAnnotationPresent(Export.class)) {
				field.setAccessible(Boolean.TRUE);				
					Export excelAttribute = field.getAnnotation(Export.class);
					concurrentHashMap.put(excelAttribute.columnSeq(), field);					
					if (field.get(object) != null && !field.get(object).toString().isEmpty()) {
						if (field.get(object) != null)
							dataRow.createCell(excelAttribute.columnSeq()).setCellValue(field.get(object).toString());
					}
				} 
			}
		}
		}catch (IllegalArgumentException e) {
			throw new ExcelCreationException("ERROR_JOB_EXCELCOLUMN", e);
		} catch (IllegalAccessException e) {
			throw new ExcelCreationException("ERROR_JOB_EXCELCOLUMN", e);
		}

	}

	@Override
	protected CellStyle setHeaderStyle(HSSFWorkbook sampleWorkBook) {
		Font font = sampleWorkBook.createFont();

		font.setColor(Font.COLOR_RED);
		font.setBoldweight(Font.BOLDWEIGHT_BOLD);
		CellStyle cellStyle = sampleWorkBook.createCellStyle();
		cellStyle.setFont(font);
		return cellStyle;
	}
	

	public void preProcess(String jobId, Object obj) {
		this.jobId = jobId;
		workbook = new HSSFWorkbook();
		HSSFSheet sampleDataSheet = null;
		// sampleDataSheet.setRandomAccessWindowSize(10);
		sampleDataSheet = (HSSFSheet) workbook.createSheet(workSheetName);
		sampleDataSheet.setDefaultColumnWidth(40);
		createHeader(obj, workbook, sampleDataSheet, 0, 0);
	}

	public Collection<Void> process(Collection<K> data) {
		LOGGER.trace("prepareExcel>>");
		int rowCount = 1;
		int colCount = 0;
		HSSFSheet sampleDataSheet = null;

		sampleDataSheet = (HSSFSheet) workbook.getSheet(workSheetName);
		rowCount = sampleDataSheet.getLastRowNum() + 1;
		LOGGER.trace("last rowCount >> " + rowCount);

		createDataRows(data, sampleDataSheet, rowCount, colCount);
		
		return null;
	}

	public void postProcess(Object obj) {
		OutputStream outputStream = createOutputStream();
		LOGGER.trace("writeExcelTo>>" + outputStream);
		try {
			workbook.write(outputStream);

		} catch (IOException e) {
			throw new ExcelCreationException("ERROR_JOB_EXCELWRITE", e);
		} finally {
			try {
				if (outputStream != null) {
					outputStream.close();
				}
			} catch (IOException e) {
				throw new ExcelCreationException("ERROR_JOB_EXCELCLOSE", e);
			}
		}

		try {
			deleteSXSSFTempFiles(workbook);
		} catch (NoSuchFieldException e) {
			throw new ExcelCreationException("ERROR_JOB_EXCELDELETE", e);
		} catch (IllegalAccessException e) {
			throw new ExcelCreationException("ERROR_JOB_EXCELDELETE", e);
		}
	}

	/**
	 * Deletes all temporary files of the HSSFWorkbook instance
	 * 
	 * @param workbook
	 * @throws NoSuchFieldException
	 * @throws IllegalAccessException
	 */
	public  void deleteSXSSFTempFiles(HSSFWorkbook workbook) throws NoSuchFieldException, IllegalAccessException {

		int numberOfSheets = workbook.getNumberOfSheets();

		// iterate through all sheets (each sheet as a temp file)
		for (int i = 1; i < numberOfSheets; i++) {
			Sheet sheetAt = workbook.getSheetAt(i);

			// delete only if the sheet is written by stream
			if (sheetAt instanceof HSSFSheet) {
				SheetDataWriter sdw = (SheetDataWriter) getPrivateAttribute(sheetAt, "_writer");

				try {
					java.lang.reflect.Method m = SheetDataWriter.class.getDeclaredMethod("getTempFile");
					m.setAccessible(true);
					File f = (File) m.invoke(sdw);
					boolean flag = f.delete();
					if (!flag)
						throw new ExcelCreationException("ERROR_JOB_EXCELDELETE");

				} catch (IllegalArgumentException e) {
					throw new ExcelCreationException("ERROR_JOB_EXCELDELETE", e);
				} catch (InvocationTargetException e) {
					throw new ExcelCreationException("ERROR_JOB_EXCELDELETE", e);
				} catch (Exception e) {
					throw new ExcelCreationException("ERROR_JOB_EXCELDELETE", e);
				}

			}
		}
	}

	/**
	 * Returns a private attribute of a class
	 * 
	 * @param containingClass
	 *            The class that contains the private attribute to retrieve
	 * @param fieldToGet
	 *            The name of the attribute to get
	 * @return The private attribute
	 * @throws NoSuchFieldException
	 * @throws IllegalAccessException
	 */
	public static Object getPrivateAttribute(Object containingClass, String fieldToGet)
			throws NoSuchFieldException, IllegalAccessException {
		// get the field of the containingClass instance
		java.lang.reflect.Field declaredField = containingClass.getClass().getDeclaredField(fieldToGet);
		// set it as accessible
		declaredField.setAccessible(true);
		// access it
		Object get = declaredField.get(containingClass);
		// return it!
		return get;
	}

	/** To create the OutputStream for writing excel */
	  @Override
	 protected OutputStream createOutputStream() {
		FileOutputStream fileOutputStream = null;
		LOGGER.trace(filePath.getAbsolutePath(), jobId + "_" + filePattern + "." + FILE_EXTENSION);
		File file = new File(filePath, jobId + "_" + filePattern + "." + FILE_EXTENSION);

		boolean flag;
		if (file.getParentFile().exists() == false) {
			flag = file.getParentFile().mkdir();
		}

		try {
			flag = file.createNewFile();
			LOGGER.trace(flag);
			fileOutputStream = new FileOutputStream(file);
		} catch (Exception e) {
			throw new ExcelCreationException("ERROR_JOB_EXCELWRITE", e);
		}

		return fileOutputStream;
	}
	
	public String localizeColumnName(String name) {
		if (name.equals("")){
			return "";
		}
		Locale locale = LocaleContextHolder.getLocale();
		String errorMessage = messageSource.getMessage(name, null, locale);
		return errorMessage;
	}

	@Override
	CellStyle setRowStyle(HSSFWorkbook sampleWorkBook) {
		// TODO Auto-generated method stub
		return null;
	}

}
